{"mappings":"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","sources":["src/index.ts","package.json","src/helpers.ts","src/base.ts"],"sourcesContent":["import { name, version } from \"../package.json\";\nimport { setApiKey, send as _send } from \"@sendgrid/mail\";\n\nimport {\n  readableStreamToString,\n  isDefined,\n  mapStringOrAddress,\n} from \"./helpers\";\nimport type {\n  SendCallback,\n  Mail,\n  AttachmentData,\n  MailDataRequired,\n  MailMessage,\n} from \"./types\";\nimport { SendGridTransportBase } from \"./base\";\n\ntype SendGridTransportOptions = {\n  apiKey?: string;\n};\n\nclass SendGridTransport extends SendGridTransportBase {\n  options: SendGridTransportOptions;\n  name: string;\n  version: string;\n  constructor(options: SendGridTransportOptions) {\n    super();\n    this.options = options || {};\n    this.name = name;\n    this.version = version;\n    if (options.apiKey) {\n      setApiKey(options.apiKey);\n    }\n  }\n\n  async send(mail: MailMessage, callback: SendCallback<any>) {\n    mail.normalize((err, source) => {\n      if (err) {\n        return callback(err, null);\n      }\n\n      const wow = source ?? {};\n\n      const msg: Partial<MailDataRequired> = {};\n      Object.keys(wow || {}).forEach((key) => {\n        switch (key) {\n          case \"subject\":\n          case \"text\":\n          case \"html\":\n            msg[key] = wow[key] as any;\n            break;\n          case \"from\":\n          case \"replyTo\":\n            msg[key] = [wow[key] ?? []].flat().map(mapStringOrAddress).shift();\n            break;\n          case \"to\":\n          case \"cc\":\n          case \"bcc\":\n            msg[key] = [wow[key] ?? []].flat().map(mapStringOrAddress);\n            break;\n          case \"attachments\":\n            this.handleAttachments(wow, msg);\n            break;\n          case \"alternatives\":\n            this.handleAlternatives(wow, msg);\n            break;\n          case \"icalEvent\":\n            {\n              let attachment: AttachmentData = {\n                content: readableStreamToString(\n                  (wow.icalEvent as Mail.IcalAttachment).content ?? \"\"\n                ),\n                filename:\n                  (wow.icalEvent as Mail.IcalAttachment).filename ||\n                  \"invite.ics\",\n                type: \"application/ics\",\n                disposition: \"attachment\",\n              };\n              msg.attachments = (msg.attachments ?? []).concat(attachment);\n            }\n            break;\n          case \"watchHtml\":\n            {\n              let alternative = {\n                content: wow.watchHtml,\n                type: \"text/watch-html\",\n              };\n              msg.content = (msg.content ?? []).concat(alternative as any);\n            }\n            break;\n          case \"normalizedHeaders\":\n            /*\n                        const headers = msg.headers || {};\n                        Object.keys(wow.normalizedHeaders || {}).forEach(header => {\n                            headers[header] = wow.normalizedHeaders[header];\n                        });\n\n                         msg.headers = headers*/\n            break;\n          case \"messageId\":\n            msg.headers = msg.headers || {};\n            msg.headers[\"message-id\"] = wow.messageId!;\n            break;\n          default:\n            (msg as any)[key] = (wow as any)[key];\n        }\n      });\n\n      if (msg.content && msg.content.length) {\n        if (msg.text) {\n          msg.content.unshift({ type: \"text/plain\", value: msg.text });\n          delete msg.text;\n        }\n        if (msg.html) {\n          msg.content.unshift({ type: \"text/html\", value: msg.html });\n          delete msg.html;\n        }\n      }\n\n      _send(msg as MailDataRequired, callback as any);\n    });\n  }\n  private handleAlternatives(\n    wow: Mail.Options,\n    msg: Partial<MailDataRequired>\n  ) {\n    if (!wow.alternatives) return;\n    let alternatives = wow.alternatives.map((entry) => {\n      let alternative = {\n        value: readableStreamToString(entry.content ?? \"\"),\n        type: entry.contentType!,\n      };\n      return alternative;\n    });\n\n    msg.content = (msg.content ?? []).concat(alternatives);\n  }\n\n  private handleAttachments(wow: Mail.Options, msg: Partial<MailDataRequired>) {\n    let attachments = (wow.attachments ?? [])\n      .map((entry) => {\n        if (!entry.content || !entry.filename) return;\n        let attachment: AttachmentData = {\n          content: readableStreamToString(entry.content),\n          filename: entry.filename,\n          type: entry.contentType,\n          disposition: \"attachment\",\n        };\n        if (entry.cid) {\n          attachment.contentId = entry.cid;\n          attachment.disposition = \"inline\";\n        }\n        return attachment;\n      })\n      .filter(isDefined);\n\n    msg.attachments = (msg.attachments ?? []).concat(attachments);\n  }\n}\n\nexport const createSendGridTransport = (options: SendGridTransportOptions) =>\n  new SendGridTransport(options);\n\nexport default createSendGridTransport;\n","{\n  \"name\": \"nodemailer-sendgrid-create-transport\",\n  \"version\": \"2.0.0\",\n  \"description\": \"\",\n  \"type\": \"module\",\n  \"source\": \"src/index.ts\",\n  \"main\": \"dist/main.js\",\n  \"types\": \"dist/types.d.ts\",\n  \"module\": \"dist/module.js\",\n  \"scripts\": {\n    \"watch\": \"parcel watch\",\n    \"build\": \"parcel build\"\n  },\n  \"keywords\": [\n    \"nodemailer\",\n    \"sendgrid\"\n  ],\n  \"author\": \"Andris Reinman\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"@sendgrid/mail\": \"^6.2.1\"\n  },\n  \"devDependencies\": {\n    \"@parcel/packager-ts\": \"2.9.2\",\n    \"@parcel/transformer-typescript-types\": \"2.9.2\",\n    \"@types/nodemailer\": \"^6.4.8\",\n    \"eslint-config-nodemailer\": \"^1.2.0\",\n    \"nodemailer\": \"^6.9.3\",\n    \"parcel\": \"^2.9.2\",\n    \"typescript\": \">=3.0.0\"\n  }\n}\n","import type Mail from \"nodemailer/lib/mailer\";\nimport type { Readable } from \"stream\";\n\nexport const readableStreamToString = (\n  value: string | Readable | Buffer\n): string => {\n  return Buffer.isBuffer(value) ? value.toString() : (value as string);\n};\nexport const isDefined = <T>(value: T | undefined): value is T => {\n  return typeof value !== \"undefined\";\n};\n\nexport const mapStringOrAddress = (entry: string | Mail.Address) => {\n  if (typeof entry == \"string\") return entry;\n\n  return {\n    name: entry.name,\n    email: entry.address,\n  };\n};\n","import type { Transport } from \"nodemailer\";\nimport { SendCallback, MailMessage } from \"./types\";\n\nexport abstract class SendGridTransportBase<T = any> implements Transport<T> {\n  abstract name: string;\n  abstract version: string;\n\n  abstract send(mail: MailMessage<T>, callback: SendCallback<T>): void;\n\n  verify?(callback: (err: Error | null, success: true) => void): void;\n  verify?(): Promise<true>;\n\n  close?(): void;\n}\n"],"names":[],"version":3,"file":"main.js.map"}