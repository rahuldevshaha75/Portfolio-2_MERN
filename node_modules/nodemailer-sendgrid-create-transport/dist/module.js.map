{"mappings":"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","sources":["src/index.ts","package.json","src/helpers.ts","src/base.ts"],"sourcesContent":["import { name, version } from \"../package.json\";\nimport { MailService } from \"@sendgrid/mail\";\n\nimport {\n  readableStreamToString,\n  isDefined,\n  mapStringOrAddress,\n} from \"./helpers\";\nimport type {\n  SendCallback,\n  Mail,\n  AttachmentData,\n  MailDataRequired,\n  MailMessage,\n} from \"./types\";\nimport { SendGridTransportBase } from \"./base\";\n\ntype SendGridTransportOptions = {\n  apiKey?: string;\n};\n\nclass SendGridTransport extends SendGridTransportBase {\n  options: SendGridTransportOptions;\n  name: string;\n  version: string;\n  private sgMail = new MailService();\n  constructor(options: SendGridTransportOptions) {\n    super();\n    this.options = options ?? {};\n    this.name = name;\n    this.version = version;\n    if (options.apiKey) {\n      this.sgMail.setApiKey(options.apiKey);\n    }\n  }\n\n  async send(mail: MailMessage, callback: SendCallback<any>) {\n    mail.normalize((err, _source) => {\n      if (err) {\n        return callback(err, null);\n      }\n\n      const source = _source ?? {};\n\n      const msg: Partial<MailDataRequired> = {};\n      Object.keys(source ?? {}).forEach((key) => {\n        switch (key) {\n          case \"subject\":\n          case \"text\":\n          case \"html\":\n            msg[key] = source[key] as any;\n            break;\n          case \"from\":\n          case \"replyTo\":\n            msg[key] = [source[key] ?? []]\n              .flat()\n              .map(mapStringOrAddress)\n              .shift();\n            break;\n          case \"to\":\n          case \"cc\":\n          case \"bcc\":\n            msg[key] = [source[key] ?? []].flat().map(mapStringOrAddress);\n            break;\n          case \"attachments\":\n            this.handleAttachments(source, msg);\n            break;\n          case \"alternatives\":\n            this.handleAlternatives(source, msg);\n            break;\n          case \"icalEvent\":\n            {\n              let attachment: AttachmentData = {\n                content: readableStreamToString(\n                  (source.icalEvent as Mail.IcalAttachment).content ?? \"\"\n                ),\n                filename:\n                  (source.icalEvent as Mail.IcalAttachment).filename ||\n                  \"invite.ics\",\n                type: \"application/ics\",\n                disposition: \"attachment\",\n              };\n              msg.attachments = (msg.attachments ?? []).concat(attachment);\n            }\n            break;\n          case \"watchHtml\":\n            {\n              let alternative = {\n                content: source.watchHtml,\n                type: \"text/watch-html\",\n              };\n              msg.content = (msg.content ?? []).concat(alternative as any);\n            }\n            break;\n          case \"normalizedHeaders\":\n            /*\n                        const headers = msg.headers || {};\n                        Object.keys(source.normalizedHeaders || {}).forEach(header => {\n                            headers[header] = source.normalizedHeaders[header];\n                        });\n\n                         msg.headers = headers*/\n            break;\n          case \"messageId\":\n            msg.headers = msg.headers ?? {};\n            msg.headers[\"message-id\"] = source.messageId!;\n            break;\n          default:\n            (msg as any)[key] = (source as any)[key];\n        }\n      });\n\n      if (msg?.content?.length) {\n        if (msg.text) {\n          msg.content.unshift({ type: \"text/plain\", value: msg.text });\n          delete msg.text;\n        }\n        if (msg.html) {\n          msg.content.unshift({ type: \"text/html\", value: msg.html });\n          delete msg.html;\n        }\n      }\n\n      this.sgMail.send(msg as MailDataRequired, callback as any);\n    });\n  }\n  private handleAlternatives(\n    source: Mail.Options,\n    msg: Partial<MailDataRequired>\n  ) {\n    if (!source.alternatives) return;\n    const alternatives = source.alternatives.map((entry) => {\n      const alternative = {\n        value: readableStreamToString(entry.content ?? \"\"),\n        type: entry.contentType!,\n      };\n      return alternative;\n    });\n\n    msg.content = (msg.content ?? []).concat(alternatives);\n  }\n\n  private handleAttachments(\n    source: Mail.Options,\n    msg: Partial<MailDataRequired>\n  ) {\n    const attachments = (source.attachments ?? [])\n      .map((entry) => {\n        if (!entry.content || !entry.filename) return;\n        const attachment: AttachmentData = {\n          content: readableStreamToString(entry.content),\n          filename: entry.filename,\n          type: entry.contentType,\n          disposition: \"attachment\",\n        };\n        if (entry.cid) {\n          attachment.contentId = entry.cid;\n          attachment.disposition = \"inline\";\n        }\n        return attachment;\n      })\n      .filter(isDefined);\n\n    msg.attachments = (msg.attachments ?? []).concat(attachments);\n  }\n}\n\nexport const createSendGridTransport = (options: SendGridTransportOptions) =>\n  new SendGridTransport(options);\n\nexport default createSendGridTransport;\n","{\n  \"name\": \"nodemailer-sendgrid-create-transport\",\n  \"version\": \"2.0.0\",\n  \"description\": \"\",\n  \"source\": \"src/index.ts\",\n  \"main\": \"dist/main.js\",\n  \"types\": \"dist/main.d.ts\",\n  \"module\": \"dist/module.js\",\n  \"scripts\": {\n    \"watch\": \"parcel watch\",\n    \"build\": \"parcel build\",\n    \"example\": \"ts-node examples/mail.ts\"\n  },\n  \"keywords\": [\n    \"nodemailer\",\n    \"sendgrid\"\n  ],\n  \"author\": \"Andris Reinman\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"@sendgrid/mail\": \"^7.7.0\"\n  },\n  \"devDependencies\": {\n    \"@parcel/packager-ts\": \"2.9.2\",\n    \"@parcel/transformer-typescript-types\": \"2.9.2\",\n    \"@types/nodemailer\": \"^6.4.8\",\n    \"eslint-config-nodemailer\": \"^1.2.0\",\n    \"nodemailer\": \"^6.9.3\",\n    \"parcel\": \"^2.9.2\",\n    \"ts-node\": \"^10.9.1\",\n    \"typescript\": \">=3.0.0\"\n  },\n  \"engines\": {\n    \"node\": \">= 12\"\n  }\n}\n","import type Mail from \"nodemailer/lib/mailer\";\nimport type { Readable } from \"stream\";\n\nexport const readableStreamToString = (\n  value: string | Readable | Buffer\n): string => {\n  return Buffer.isBuffer(value) ? value.toString() : (value as string);\n};\nexport const isDefined = <T>(value: T | undefined): value is T => {\n  return typeof value !== \"undefined\";\n};\n\nexport const mapStringOrAddress = (entry: string | Mail.Address) => {\n  if (typeof entry == \"string\") return entry;\n\n  return {\n    name: entry.name,\n    email: entry.address,\n  };\n};\n","import type { Transport } from \"nodemailer\";\nimport { SendCallback, MailMessage } from \"./types\";\n\nexport abstract class SendGridTransportBase<T = any> implements Transport<T> {\n  abstract name: string;\n  abstract version: string;\n\n  abstract send(mail: MailMessage<T>, callback: SendCallback<T>): void;\n\n  verify?(callback: (err: Error | null, success: true) => void): void;\n  verify?(): Promise<true>;\n\n  close?(): void;\n}\n"],"names":[],"version":3,"file":"module.js.map","sourceRoot":"../"}